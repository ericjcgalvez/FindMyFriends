#' @include aaa.R
#' @include pgVirtual.R
NULL

#' @describeIn graphGrouping graph grouping for all pgVirtual subclasses
#' 
#' @param similarity A similarity matrix with rows and columns corresponding to
#' the genes in the pangenome.
#' 
#' @param algorithm A string naming the algorithm. See \code{\link[igraph]{communities}}
#' for an overview. The trailing '.community' can be omitted from the name. 
#' Default is 'infomap', which is also the recommended.
#' 
setMethod(
    'graphGrouping', 'pgVirtual',
    function(object, similarity, algorithm, ...) {
        .fillDefaults(defaults(object))
        
        members <- igGroup(similarity, algorithm, ...)
        groupGenes(object, as.integer(members))
    }
)

#' @describeIn gpcGrouping gpc grouping for all pgVirtual subclasses
#' 
#' @param lowMem logical. Should low memory footprint be ensured over 
#' computation speed
#' 
#' @param kmerSize The size of the kmer's used for the comparison. If two values
#' are given and the 'tree' argument is missing, the second value is used for 
#' tree generation. If only one value is given it is recycled.
#'   
#' @param tree An optional tree of class dendrogram (or that can be coerced to 
#' one) to guide the recursive algorithm. If none is supplied it will be 
#' generated by clustering the organisms by their total kmer numbers (summing up
#' for each of their genes).
#'   
#' @param lowerLimit A numeric giving the lower bounds of similarity below which
#' it will be set to zero.
#'   
#' @param pParam An optional BiocParallelParam object that defines the workers 
#' used for parallelisation.
#'   
#' @param cacheDB A \code{\linkS4class{filehash}} object or a path to a 
#' directory where cached results should be stored. If omitted caching will not
#' be done. Highly recommended for long running instances.
#' 
#' @importFrom kebabs getExRep spectrumKernel
#' 
#' @importFrom filehash dbCreate dbInit
#' 
setMethod(
    'gpcGrouping', 'pgVirtual',
    function(object, lowMem, kmerSize, tree, lowerLimit, pParam, cacheDB) {
        .fillDefaults(defaults(object))
        
        args <- mget(ls())
        args$lowMem <- NULL
        args$object <- NULL
        args$pangenome <- object
        
        if(!missing(cacheDB)) {
            if(!inherits(cacheDB, 'filehash')) {
                if(suppressMessages(dbCreate(cacheDB, type='RDS'))) {
                    cacheDB <- dbInit(cacheDB, type='RDS')
                } else {
                    stop('Failed to create cache databse')
                }
            }
            args$cacheDB <- cacheDB
        }
        if(missing(tree)) {
            tree <- orgTree(object, type='kmer', kmerSize=rep(kmerSize, length=2)[2], dist='euclidean', clust='ward.D2')
        }
        args$tree <- as.dendrogram(tree)
        if(!lowMem) {
            args$kmerSize <- NULL
            args$er <- getExRep(genes(object), spectrumKernel(kmerSize))
        }
        groups <- do.call(recurseCompare, args)
        manualGrouping(object, groups)
    }
)

#' @describeIn manualGrouping manual grouping defined by integer vector
#' 
setMethod(
    'manualGrouping', c('pgVirtual', 'integer'),
    function(object, groups) {
        groupGenes(object, groups)
    }
)
#' @describeIn manualGrouping manual grouping defined by list
#' 
setMethod(
    'manualGrouping', c('pgVirtual', 'list'),
    function(object, groups) {
        groups <- groups[order(sapply(groups, length), decreasing=TRUE)]
        members <- rep(1:length(groups), sapply(groups, length))
        members[unlist(groups)] <- as.integer(members)
        
        manualGrouping(object, members)
    }
)


### GROUPING HELPER FUNCTIONS

#' Extract community membership based on similarity matrix
#' 
#' This function creates an igraph object and runs community detection on it,
#' returning the community memberships of the vertices.
#' 
#' @param similarity A similarity matrix with weights in the lower triangle. 
#' Diagonal is ignored.
#' 
#' @param algorithm The community detection algorithm to use
#' 
#' @param ... Parameters passed on to the community detection
#' 
#' @return An integer vector with an element for each vertice
#' 
#' @importFrom igraph graph_from_adjacency_matrix
#' 
#' @noRd
#' 
igGroup <- function(similarity, algorithm, ...) {
    graph <- graph_from_adjacency_matrix(similarity, mode='lower', weighted=TRUE, diag=FALSE)
    igMembers(graph, algorithm, ...)
}

#' Extract community membership from a graph object
#' 
#' This function runs community detection on a graph based on the name of the
#' algorithm.
#' 
#' @param graph An igraph object
#' 
#' @param algorithm The community detection algorithm to use
#' 
#' @param ... Parameters passed on to the community detection
#' 
#' @return An integer vector with an element for each vertice
#' 
#' @importFrom igraph membership cluster_edge_betweenness cluster_fast_greedy cluster_infomap cluster_label_prop cluster_leading_eigen cluster_louvain cluster_optimal cluster_spinglass cluster_walktrap
#' 
#' @noRd
#' 
igMembers <- function(graph, algorithm, ...) {
    algParam <- list(...)
    algParam$graph <- graph
    if(!grepl(pattern = 'cluster_', x = algorithm)) {
        algorithm <- paste0('cluster_', algorithm)
    }
    community <- do.call(algorithm, algParam)
    membership(community)
}

#' Create a combined graph of all-vs-all within groups comparisons
#' 
#' This function calculates all-vs-all similarities for members within each 
#' group and return the result as a weighted graph.
#' 
#' @param pangenome A pgVirtual subclass
#' 
#' @param groups A list with group member indexes
#' 
#' @param er ExplicitRepresentation for all genes given in groups
#' 
#' @param lowerLimit The lower threshold for similarity, below which it will be
#' set to 0
#' 
#' @return An igraph object containing all groups as disconnected subgraphs
#' 
#' @importFrom kebabs linearKernel
#' @importFrom igraph as_data_frame graph_from_adjacency_matrix graph_from_data_frame
#' 
#' @noRd
#' 
groupToGraph <- function(pangenome, groups, er, lowerLimit) {
    edges <- lapply(groups, function(members, er, lowerLimit) {
        sim <- linearKernel(er, selx=members, sparse=TRUE, diag=FALSE, lowerLimit=lowerLimit)
        as_data_frame(graph_from_adjacency_matrix(sim, mode='lower', weighted=TRUE, diag=FALSE))
    }, er=er, lowerLimit=lowerLimit)
    edges <- do.call(rbind, edges)
    graph_from_data_frame(edges, directed=FALSE, vertices=data.frame(name=geneNames(pangenome)))
}